@viewModel BcsAnalysisWeb.ViewModels.DefaultViewModel, BcsAnalysisWeb

<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <dot:RequiredResource Name="BootstrapJs" />
    <dot:RequiredResource Name="BootstrapCss" />
    <dot:RequiredResource Name="Site" />
    <meta charset="utf-8" />
    <title></title>
</head>
<body>
    <dot:InlineScript Dependencies="knockout">
        var lastCaret = 0;

        function getCharacterOffsetWithin(range, node) {
            var treeWalker = document.createTreeWalker(
                node,
                NodeFilter.SHOW_TEXT,
                function (node) {
                    var nodeRange = document.createRange();
                    nodeRange.selectNode(node);
                    return nodeRange.compareBoundaryPoints(Range.END_TO_END, range) < 1 ?
                        NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
                },
                false
            );

            var charCount = 0;
            while (treeWalker.nextNode()) {
                charCount += treeWalker.currentNode.length;
            }
            if (range.startContainer.nodeType == 3) {
                charCount += range.startOffset;
            }
            return charCount;
        }

        function getCaretPosition(node) {
            var caretPos = 0,
              sel, range;
            if (window.getSelection) {
                sel = window.getSelection();
                if (sel.rangeCount) {
                    range = sel.getRangeAt(0);
                    return getCharacterOffsetWithin(range, node);
                }
            } else if (document.selection && document.selection.createRange) {
                range = document.selection.createRange();
                return getCharacterOffsetWithin(range, node); 
            }
            return caretPos;
        }

        var setCaret = function (e, cp)
        {
            var carretSet = false;

            var placeCaret = function (item, position) {
                var range = document.createRange();
                range.setStart(item, position)
                range.setEnd(item, position)

                var sel = window.getSelection()
                sel.removeAllRanges()
                sel.addRange(range)
                carretSet = true;
            }

            var setCaretCore = function (element, caretPosition) {
                var charsInNode = 0;

                element.childNodes.forEach(function (item, index) {
                    if (carretSet) { return 0; }

                    if (item.nodeType === 3) {
                        var textContentLenght = item.textContent.length;
                        var relativeCaretPosition = caretPosition - charsInNode;

                        if (0 <= relativeCaretPosition && relativeCaretPosition <= textContentLenght) {
                            placeCaret(item, relativeCaretPosition);
                        }
                        else {
                            charsInNode += textContentLenght
                        }
                        return;
                    }
                    if (item.nodeType == 1) {
                        charsInNode += setCaretCore(item, caretPosition - charsInNode)
                    }
                });

                if (carretSet) { return 0; }
                return charsInNode;
            }

            setCaretCore(e, cp);
        }

        ko.bindingHandlers.htmlLazy = {
            update: function (element, valueAccessor) {
                var value = ko.unwrap(valueAccessor());
 
                if (element.isContentEditable) {
                    lastCaret = getCaretPosition(element)
                    console.log(lastCaret);
                    element.innerHTML = value;
                    setCaret(element, lastCaret);
                }
               
            }
        };
        ko.bindingHandlers.contentEditable = {
            init: function (element, valueAccessor, allBindingsAccessor) {
                var value = ko.unwrap(valueAccessor()),
                    htmlLazy = allBindingsAccessor().htmlLazy;

                $(element).on("input", function () {
                    if (this.isContentEditable && ko.isWriteableObservable(htmlLazy)) {
                        htmlLazy(this.innerHTML);
                    }
                }).on('change', function (e) {
                });
            },
            update: function (element, valueAccessor) {
                var value = ko.unwrap(valueAccessor());

                element.contentEditable = value;

                if (!element.isContentEditable) {
                    $(element).trigger("input");
                }
            }
        };
    </dot:InlineScript>
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <h1>
                    <dot:Literal Text="{value: Title}" />
                </h1>
            </div>
            <div class="col-md-6">
                <dot:Repeater class="reaction-list" WrapperTagName="ul" DataSource="{value: Reactions}">
                    <ItemTemplate>
                        <li>
                            {{value: Display}}
                            <dot:Button class="btn btn-sm" Click="{command: _root.DrawTree(Id)}" Text="Syntax tree" />
                            <dot:Button class="btn btn-sm" Click="{command: _root.DrawSemanticTree(Id)}" Text="Semantic tree" />
                        </li>
                    </ItemTemplate>
                </dot:Repeater>
            </div>
            <div class="col-md-6">
                <dot:GridView class="table" DataSource="{value: EntityDataSet}">
                    <Columns>
                        <dot:GridViewTextColumn HeaderText="Name" ValueBinding="{value: Name}" />
                        <dot:GridViewTextColumn HeaderText="Type" ValueBinding="{value: Type}" />
                        <dot:GridViewTemplateColumn HeaderText="Child entities">
                            <dot:Repeater DataSource="{value: Children}">
                                {{value: _this}}
                            </dot:Repeater>
                        </dot:GridViewTemplateColumn>
                    </Columns>
                </dot:GridView>
            </div>
            <div class="col-md-12">
                <dot:TextBox Text="" Changed="{command: DrawLive()}" style="display: none;" />
                <div class="form-control" contenteditable="true"
                     data-bind="contentEditable: true, htmlLazy: TextEdit"
                     spellcheck="false"
                     onkeyup="if(!dotvvm.isViewModelUpdating){dotvvm.postbackScript('DrawLive()')('root', this, [], '', true, '$root', null, null)};return false;"></div>
            </div>
            <div class="col-md-12">
                <cc:Tree class="tree"
                         DataSource="{value: SyntaxToDraw}"
                         NodeCollectionWrapperTag="ul"
                         NodeWrapperTag="li"
                         RenderSettings.Mode="Server"
                         PostBack.Update="true">
                    <ItemTemplate>
                        <a class="{value: Data.HasErrors ? "error":""}" href="#">
                            <h4>{{value: Data.NodeName}}</h4>
                            {{value: Data.Dispaly}}
                            <dot:Button Click="{command: _root.Click(_this)}" Text="Add" />
                            <dot:Repeater class="error-list" WrapperTagName="ul" DataSource="{value: Data.Errors}">
                                <li>
                                    {{value: _this}}
                                </li>
                            </dot:Repeater>
                        </a>
                    </ItemTemplate>
                </cc:Tree>

                <dot:Repeater DataSource="{value: SemanticErrors}" WrapperTagName="ul">
                    <li><span class="text-danger">{{value: AssociatedSyntax}}</span> {{value: Message}}</li>
                </dot:Repeater>
                <cc:Tree class="tree"
                         DataSource="{value: SemanticToDraw}"
                         NodeCollectionWrapperTag="ul"
                         NodeWrapperTag="li"
                         RenderSettings.Mode="Server"
                         PostBack.Update="true">
                    <ItemTemplate>
                        <a href="#">
                            <h4>{{value: Data.Type}}</h4>
                            Syntax: {{value: Data.SyntaxNode}} <br />
                            Symbol: {{value: Data.Symbol}} <br />
                        </a>
                    </ItemTemplate>
                </cc:Tree>
            </div>
        </div>
    </div>
</body>
</html>